ChapterOne Review
=================

Entities versus ValueObjects
----------------------------
Our first steps were made to get a web based cargo shipping system up and running. We setup a web app by using [Zend Framework 2 SkeletonApplication](https://github.com/zendframework/ZendSkeletonApplication) and we have introduced the first two domain model classes named [Cargo](https://github.com/prooph/php-ddd-cargo-sample/blob/ChapterOne/module/Application/src/Application/Domain/Model/Cargo/Cargo.php) and [Voyage](https://github.com/prooph/php-ddd-cargo-sample/blob/ChapterOne/module/Application/src/Application/Domain/Model/Voyage/Voyage.php). Even now you can see some important concepts. An [EntityInterface](https://github.com/prooph/php-ddd-cargo-sample/blob/ChapterOne/module/Application/src/Application/Domain/Shared/EntityInterface.php) marks a Cargo as Entity and a [ValueObjectInterface](https://github.com/prooph/php-ddd-cargo-sample/blob/ChapterOne/module/Application/src/Application/Domain/Shared/ValueObjectInterface.php) marks the TrackingId of a Cargo as ValueObject. Same applies for Voyage and it's VoyageNumber.
Differentiate between Entities and ValueObjects is one of the most essential concepts of DDD. You should [read about it](http://martinfowler.com/bliki/EvansClassification.html) carefully and get a felling of when it's better to design an Entity and when it's better to use an immutable ValueObject. In case of Cargo and it's TrackingId the questions can be answered easy. A Cargo has an identity and therefor it is an Entity. The TrackingId is a value representing the identifier of a Cargo. You can model the TrackingId as simple string property of the Cargo class, but in the long run it's easier to deal with a ValueObject representing the business rule that a Cargo is identified by a TrackingId.

Separating Domain Model and technical implementation
----------------------------------------------------
Another concept of Domain Driven Design is, that the database should not be a leading part when it comes to design decisions. Determine use cases and focus on them. Separating model and storage mechanism can help you avoid [anemic domain models](http://www.martinfowler.com/bliki/AnemicDomainModel.html) and give you the advantage of a changeable database layer. For now we've decided to use [doctrine 2](http://www.doctrine-project.org/) to persist our entities. Doctrine 2 is a powerful Object Relational Mapper and fits well with DDD. Doctrine already knows Entities, but be careful, not every Doctrine Entity must also be a DDD Entity! We will return to it in a later chapter. First lets have a look of how we have separated the model from doctrine. DDD suggests using the [repository pattern](http://martinfowler.com/eaaCatalog/repository.html) to work with databases. This makes it possible to define a [repository interface](https://github.com/prooph/php-ddd-cargo-sample/blob/ChapterOne/module/Application/src/Application/Domain/Model/Cargo/CargoRepositoryInterface.php) for each entity. The implementation is placed in another directory called [infrastructure](https://github.com/prooph/php-ddd-cargo-sample/tree/ChapterOne/module/Application/src/Application/Infrastructure).  In short, the infrastructure directory contains technical implementations of domain requirements.

Acknowledgement
---------------
Enjoy our composition of [ZF2](http://framework.zend.com/), [doctrine 2](http://www.doctrine-project.org/) and [DDD](http://dddcommunity.org/) and have a look at the other libraries used in this project. The layout is made with [Bootstrap](http://getbootstrap.com/). Bootstrap is integrated in ZF2 with [mwillbanks/zfc-twitter-bootstrap module](https://github.com/mwillbanks/ZfcTwitterBootstrap). Doctrine is integrated via [doctrine/doctrine-orm-module](https://github.com/doctrine/DoctrineORMModule). UnitTests are written with the famous [PHPUnit framework](http://phpunit.de/) and Behavior Tests are processed by [Behat and Mink](http://behat.org/).